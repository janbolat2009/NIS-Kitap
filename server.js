import express from 'express';
import cors from 'cors';
import mongoose from 'mongoose';
import { OpenAI } from 'openai';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(express.json({ limit: '50mb' }));
app.use(cors({
  origin: ['http://localhost:8080', 'http://localhost:3000'],
  credentials: true
}));

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
}).then(() => {
  console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ MongoDB');
}).catch(err => {
  console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB:', err);
});

// –°—Ö–µ–º–∞ –∫–Ω–∏–≥–∏
const bookSchema = new mongoose.Schema({
  title: { type: String, required: true },
  author: { type: String, required: true },
  genre: { type: String, default: '–ù–µ —É–∫–∞–∑–∞–Ω–æ' },
  description: { type: String, default: '' },
  embedding: [Number],
  createdAt: { type: Date, default: Date.now }
});

const Book = mongoose.model('Book', bookSchema);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OpenAI
const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY 
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ API –∫–ª—é—á–∞
if (!process.env.OPENAI_API_KEY) {
  console.error('‚ùå OPENAI_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ!');
} else {
  console.log('‚úÖ OpenAI API –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω');
}

// –§—É–Ω–∫—Ü–∏—è –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Å—Ö–æ–¥—Å—Ç–≤–∞
function cosineSimilarity(vecA, vecB) {
  if (!vecA || !vecB || vecA.length !== vecB.length) return 0;
  
  const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
  
  return dotProduct / (magnitudeA * magnitudeB) || 0;
}

// –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤
async function addEmbeddingsToBooks() {
  try {
    const books = await Book.find({});
    console.log(`üìö –ù–∞–π–¥–µ–Ω–æ –∫–Ω–∏–≥ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤: ${books.length}`);
    
    let processed = 0;
    for (const book of books) {
      if (!book.embedding || book.embedding.length === 0) {
        const text = `${book.title} ${book.author} ${book.genre} ${book.description || ''}`;
        console.log(`üîÑ –ì–µ–Ω–µ—Ä–∏—Ä—É—é —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è: ${book.title}`);
        
        try {
          const response = await openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: text,
            dimensions: 256,
          });
          
          book.embedding = response.data[0].embedding;
          await book.save();
          processed++;
          console.log(`‚úÖ –≠–º–±–µ–¥–¥–∏–Ω–≥ –¥–æ–±–∞–≤–ª–µ–Ω –¥–ª—è: ${book.title}`);
          
          // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.error(`‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ –¥–ª—è "${book.title}":`, error.message);
        }
      }
    }
    console.log(`üéâ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∫–Ω–∏–≥: ${processed}`);
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤:', error);
  }
}

// –ó–∞–ø—É—Å–∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞
addEmbeddingsToBooks();

// API Routes

// –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
app.get('/', (req, res) => {
  res.json({ 
    message: 'NIS Kitap Server —Ä–∞–±–æ—Ç–∞–µ—Ç!', 
    status: 'OK',
    timestamp: new Date().toISOString()
  });
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–Ω–∏–≥
app.get('/api/books', async (req, res) => {
  try {
    const books = await Book.find({}, 'title author genre description').lean();
    console.log(`üìñ GET /api/books - –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ: ${books.length} –∫–Ω–∏–≥`);
    res.json(books);
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–Ω–∏–≥:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–Ω–∏–≥' });
  }
});

// –ü–æ–∏—Å–∫ –ø–æ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞–º (–Ω–æ–≤—ã–π endpoint)
app.post('/api/search', async (req, res) => {
  const query = req.body.query ? req.body.query.trim() : '';
  console.log('üîç –ü–æ–∏—Å–∫ –ø–æ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞–º:', query);
  
  if (!query) {
    return res.status(400).json({ error: '–ó–∞–ø—Ä–æ—Å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' });
  }

  try {
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query,
      dimensions: 256,
    });
    
    const queryEmbedding = response.data[0].embedding;
    const books = await Book.find({}, 'title author genre description embedding').lean();
    
    const results = books
      .filter(book => book.embedding && book.embedding.length > 0)
      .map(book => ({
        ...book,
        score: cosineSimilarity(queryEmbedding, book.embedding),
      }))
      .filter(result => result.score > 0.3)
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);

    console.log(`üìä –ù–∞–π–¥–µ–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: ${results.length}`);
    res.json(results);
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø–æ–∏—Å–∫–∞' });
  }
});

// OpenAI —Ä–æ—É—Ç—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–æ–º
app.get('/api/openai/test', (req, res) => {
  res.json({ 
    message: 'OpenAI route is working!', 
    timestamp: new Date().toISOString(),
    hasApiKey: !!process.env.OPENAI_API_KEY,
    mongoConnected: mongoose.connection.readyState === 1
  });
});

// –û—Å–Ω–æ–≤–Ω–æ–π —Ä–æ—É—Ç –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞ (—Å–æ–≤–º–µ—Å—Ç–∏–º —Å –≤–∞—à–∏–º App.vue)
app.post('/api/openai/search', async (req, res) => {
  const startTime = Date.now();
  
  try {
    const { prompt } = req.body;
    
    if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
      return res.status(400).json({ 
        error: '–ü–æ–ª–µ "prompt" –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–µ–∫—Å—Ç' 
      });
    }

    console.log('ü§ñ OpenAI –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ GPT:', prompt.trim());

    // –í–∞—Ä–∏–∞–Ω—Ç 1: –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ —ç–º–±–µ–¥–¥–∏–Ω–≥–∏ (–±–æ–ª–µ–µ —Ç–æ—á–Ω—ã–π)
    if (await Book.countDocuments({ embedding: { $exists: true, $ne: [] } }) > 0) {
      console.log('üìä –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∏—Å–∫ –ø–æ —ç–º–±–µ–¥–¥–∏–Ω–≥–∞–º');
      
      const response = await openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: prompt.trim(),
        dimensions: 256,
      });
      
      const queryEmbedding = response.data[0].embedding;
      const books = await Book.find({}, 'title author genre description embedding').lean();
      
      const results = books
        .filter(book => book.embedding && book.embedding.length > 0)
        .map(book => ({
          title: book.title,
          author: book.author,
          genre: book.genre || '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
          description: book.description || '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
          score: cosineSimilarity(queryEmbedding, book.embedding),
        }))
        .filter(result => result.score > 0.2)
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);

      if (results.length > 0) {
        const responseTime = Date.now() - startTime;
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ —á–µ—Ä–µ–∑ —ç–º–±–µ–¥–¥–∏–Ω–≥–∏: ${results.length} –∫–Ω–∏–≥ –∑–∞ ${responseTime}ms`);
        return res.json({ books: results, method: 'embeddings', responseTime });
      }
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ GPT (fallback)
    console.log('ü§ñ –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —á–µ—Ä–µ–∑ GPT');
    
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: '–¢—ã - –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫. –†–µ–∫–æ–º–µ–Ω–¥—É–π —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–Ω–∏–≥–∏ –≤ —Å—Ç—Ä–æ–≥–æ–º JSON —Ñ–æ—Ä–º–∞—Ç–µ.'
        },
        {
          role: 'user',
          content: `–†–µ–∫–æ–º–µ–Ω–¥—É–π 3-5 —Ä–µ–∞–ª—å–Ω—ã—Ö –∫–Ω–∏–≥ –ø–æ –∑–∞–ø—Ä–æ—Å—É: "${prompt.trim()}". 
          –û—Ç–≤–µ—Ç—å —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –º–∞—Å—Å–∏–≤–∞:
          [{"title": "–Ω–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–∏–≥–∏", "author": "–∞–≤—Ç–æ—Ä", "genre": "–∂–∞–Ω—Ä", "description": "–∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ"}]`
        }
      ],
      max_tokens: 500,
      temperature: 0.7,
    });

    const text = response.choices[0].message.content.trim();
    let books;

    try {
      const cleanedText = text
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .replace(/^[^[\{]*/, '')
        .replace(/[^}\]]*$/, '')
        .trim();
      
      books = JSON.parse(cleanedText);
      
      if (!Array.isArray(books)) {
        throw new Error('–û—Ç–≤–µ—Ç –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º');
      }

      books = books.filter(book => 
        book && book.title && book.author
      ).map(book => ({
        title: String(book.title).trim(),
        author: String(book.author).trim(),
        genre: book.genre ? String(book.genre).trim() : '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
        description: book.description ? String(book.description).trim() : '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'
      }));

    } catch (parseError) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ GPT –æ—Ç–≤–µ—Ç–∞:', parseError.message);
      books = [{
        title: "–ü–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤",
        author: "–°–∏—Å—Ç–µ–º–∞",
        genre: "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
        description: "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å"
      }];
    }

    const responseTime = Date.now() - startTime;
    console.log(`‚úÖ GPT –ø–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ ${responseTime}ms`);
    
    res.json({ 
      books, 
      method: 'gpt-generation',
      responseTime,
      query: prompt.trim()
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error('‚ùå –û—à–∏–±–∫–∞ OpenAI –ø–æ–∏—Å–∫–∞:', error.message);

    let userError = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∫–Ω–∏–≥';
    let statusCode = 500;

    if (error.response?.status === 401) {
      userError = '–ü—Ä–æ–±–ª–µ–º–∞ —Å API –∫–ª—é—á–æ–º OpenAI';
      statusCode = 401;
    } else if (error.response?.status === 429) {
      userError = '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ OpenAI';
      statusCode = 429;
    }

    res.status(statusCode).json({ 
      error: userError,
      responseTime
    });
  }
});

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π –∫–Ω–∏–≥–∏
app.post('/api/books', async (req, res) => {
  try {
    const { title, author, genre, description } = req.body;
    
    if (!title || !author) {
      return res.status(400).json({ error: '–ù–∞–∑–≤–∞–Ω–∏–µ –∏ –∞–≤—Ç–æ—Ä –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
    }

    const book = new Book({
      title: title.trim(),
      author: author.trim(),
      genre: genre ? genre.trim() : '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
      description: description ? description.trim() : ''
    });

    await book.save();
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥ –¥–ª—è –Ω–æ–≤–æ–π –∫–Ω–∏–≥–∏
    try {
      const text = `${book.title} ${book.author} ${book.genre} ${book.description}`;
      const response = await openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: text,
        dimensions: 256,
      });
      
      book.embedding = response.data[0].embedding;
      await book.save();
      console.log(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–∏–≥–∞ —Å —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–º: ${book.title}`);
    } catch (embError) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —ç–º–±–µ–¥–¥–∏–Ω–≥–∞ –¥–ª—è –Ω–æ–≤–æ–π –∫–Ω–∏–≥–∏:', embError.message);
    }

    res.status(201).json(book);
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–Ω–∏–≥–∏:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–Ω–∏–≥–∏' });
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ä–æ—É—Ç–æ–≤
app.use('*', (req, res) => {
  res.status(404).json({ 
    error: '–†–æ—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω',
    available: [
      'GET /',
      'GET /api/books',
      'POST /api/books',
      'POST /api/search',
      'GET /api/openai/test',
      'POST /api/openai/search'
    ]
  });
});

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
app.use((error, req, res, next) => {
  console.error('üí• –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
  res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(port, () => {
  console.log(`üöÄ –°–µ—Ä–≤–µ—Ä NIS Kitap –∑–∞–ø—É—â–µ–Ω –Ω–∞ http://localhost:${port}`);
  console.log(`üìö API –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:${port}/api`);
  console.log(`ü§ñ OpenAI —Ç–µ—Å—Ç: http://localhost:${port}/api/openai/test`);
});